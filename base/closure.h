// This file was GENERATED by command:
//     pump.py closure.h.pump
// DO NOT EDIT BY HAND!!!

// Copyright (c) 2013, The Toft Authors.
// All rights reserved.
//
// Author: CHEN Feng <chen3feng@gmail.com>

#ifndef TOFT_BASE_CLOSURE_H
#define TOFT_BASE_CLOSURE_H

/////////////////////////////////////////////////////
// DO NOT EDIT!!!
// This header file is auto generated by the command: pump.py closure.h.pump
// Edit the generator if necessary.
/////////////////////////////////////////////////////

// GLOBAL_NOLINT(whitespace/indent)
// GLOBAL_NOLINT(whitespace/line_length)
// GLOBAL_NOLINT(whitespace/parens)

namespace toft {

// Base class for all Closures
class ClosureBase
{
public:
    virtual ~ClosureBase();
    virtual bool IsPermanent() const = 0;
};

// Primary template
template <typename Signature>class Closure : public ClosureBase
{
};

// Specified for 0 arguments
template <
typename R >
class Closure<R ()>
    : public ClosureBase
{
public:
    virtual R Run() = 0;
};

// Specified for 1 arguments
template <
typename R , typename A1>
class Closure<R (A1)>
    : public ClosureBase
{
public:
    virtual R Run(A1 a1) = 0;
};

// Specified for 2 arguments
template <
typename R , typename A1, typename A2>
class Closure<R (A1, A2)>
    : public ClosureBase
{
public:
    virtual R Run(A1 a1, A2 a2) = 0;
};

// Specified for 3 arguments
template <
typename R , typename A1, typename A2, typename A3>
class Closure<R (A1, A2, A3)>
    : public ClosureBase
{
public:
    virtual R Run(A1 a1, A2 a2, A3 a3) = 0;
};

// Specified for 4 arguments
template <
typename R , typename A1, typename A2, typename A3, typename A4>
class Closure<R (A1, A2, A3, A4)>
    : public ClosureBase
{
public:
    virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4) = 0;
};

// Specified for 5 arguments
template <
typename R , typename A1, typename A2, typename A3, typename A4,
         typename A5>
class Closure<R (A1, A2, A3, A4, A5)>
    : public ClosureBase
{
public:
    virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) = 0;
};

// Specified for 6 arguments
template <
typename R , typename A1, typename A2, typename A3, typename A4,
         typename A5, typename A6>
class Closure<R (A1, A2, A3, A4, A5, A6)>
    : public ClosureBase
{
public:
    virtual R Run(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) = 0;
};

// Delete p in dtor automatically if Enabled is true
template <bool Enabled, typename T>
class ConditionalAutoDeleter
{
public:
    explicit ConditionalAutoDeleter(T* p)
        : m_p(p)
    {
    }
    ~ConditionalAutoDeleter()
    {
        if (Enabled)
            delete m_p;
    }
private:
    ConditionalAutoDeleter(const ConditionalAutoDeleter&);
    ConditionalAutoDeleter& operator=(const ConditionalAutoDeleter&);
private:
    T* m_p;
};

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass >
class MethodClosure_Arg0_Bind0 : public Closure<R ()> {
    typedef R (MethodClass::*MethodType)();
public:
    MethodClosure_Arg0_Bind0(Class *object, MethodType method):
        m_object(object), m_method(method) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg0_Bind0> self_deleter(this);
        return (m_object->*m_method)();
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
};

template <typename R, typename Class, typename MethodClass>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)()) {
    return new MethodClosure_Arg0_Bind0<false, R, Class, MethodClass>(
               object, method);
}

template <typename R, typename Class, typename MethodClass>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)()) {
    return new MethodClosure_Arg0_Bind0<true, R, Class, MethodClass>(
               object, method);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R>
class FunctionClosure_Arg0_Bind0 : public Closure<R ()> {
    typedef R (*FunctionType)();
public:
    FunctionClosure_Arg0_Bind0(FunctionType function):
        m_function(function) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg0_Bind0> self_deleter(this);
        return m_function();
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
};

template <typename R>
Closure<R ()>*
NewClosure(R (*function)()) {
    return new FunctionClosure_Arg0_Bind0<false, R>(function);
}

template <typename R>
Closure<R ()>*
NewPermanentClosure(R (*function)()) {
    return new FunctionClosure_Arg0_Bind0<true, R>(function);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1 , typename PreArg1>
class MethodClosure_Arg0_Bind1 : public Closure<R ()> {
    typedef R (MethodClass::*MethodType)(Arg1);
public:
    MethodClosure_Arg0_Bind1(Class *object, MethodType method, PreArg1 pa1):
        m_object(object), m_method(method), m_pa1(pa1) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg0_Bind1> self_deleter(this);
        return (m_object->*m_method)(m_pa1);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename PreArg1>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1), PreArg1 pa1) {
    return new MethodClosure_Arg0_Bind1<false, R, Class, MethodClass, Arg1,
           PreArg1>(
               object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename PreArg1>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1),
                    PreArg1 pa1) {
    return new MethodClosure_Arg0_Bind1<true, R, Class, MethodClass, Arg1,
           PreArg1>(
               object, method, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename PreArg1>
class FunctionClosure_Arg0_Bind1 : public Closure<R ()> {
    typedef R (*FunctionType)(Arg1);
public:
    FunctionClosure_Arg0_Bind1(FunctionType function, PreArg1 pa1):
        m_function(function), m_pa1(pa1) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg0_Bind1> self_deleter(this);
        return m_function(m_pa1);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
};

template <typename R, typename Arg1, typename PreArg1>
Closure<R ()>*
NewClosure(R (*function)(Arg1), PreArg1 pa1) {
    return new FunctionClosure_Arg0_Bind1<false, R, Arg1, PreArg1>(function,
            pa1);
}

template <typename R, typename Arg1, typename PreArg1>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1), PreArg1 pa1) {
    return new FunctionClosure_Arg0_Bind1<true, R, Arg1, PreArg1>(function,
            pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2 , typename PreArg1,
     typename PreArg2>
class MethodClosure_Arg0_Bind2 : public Closure<R ()> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2);
public:
    MethodClosure_Arg0_Bind2(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg0_Bind2> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename PreArg1, typename PreArg2>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2), PreArg1 pa1,
           PreArg2 pa2) {
    return new MethodClosure_Arg0_Bind2<false, R, Class, MethodClass, Arg1,
           Arg2, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename PreArg1, typename PreArg2>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2),
                    PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg0_Bind2<true, R, Class, MethodClass, Arg1,
           Arg2, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename PreArg1,
     typename PreArg2>
class FunctionClosure_Arg0_Bind2 : public Closure<R ()> {
    typedef R (*FunctionType)(Arg1, Arg2);
public:
    FunctionClosure_Arg0_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
        m_function(function), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg0_Bind2> self_deleter(this);
        return m_function(m_pa1, m_pa2);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
         typename PreArg2>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2), PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg0_Bind2<false, R, Arg1, Arg2, PreArg1,
           PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1,
         typename PreArg2>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2), PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg0_Bind2<true, R, Arg1, Arg2, PreArg1,
           PreArg2>(function, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
     typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg0_Bind3 : public Closure<R ()> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3);
public:
    MethodClosure_Arg0_Bind3(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2),
        m_pa3(pa3) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg0_Bind3> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename PreArg1, typename PreArg2,
         typename PreArg3>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg0_Bind3<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename PreArg1, typename PreArg2,
         typename PreArg3>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg0_Bind3<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
     typename PreArg2, typename PreArg3>
class FunctionClosure_Arg0_Bind3 : public Closure<R ()> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3);
public:
    FunctionClosure_Arg0_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg0_Bind3> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2,
           PreArg3 pa3) {
    return new FunctionClosure_Arg0_Bind3<false, R, Arg1, Arg2, Arg3, PreArg1,
           PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2,
                    PreArg3 pa3) {
    return new FunctionClosure_Arg0_Bind3<true, R, Arg1, Arg2, Arg3, PreArg1,
           PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4 , typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4>
class MethodClosure_Arg0_Bind4 : public Closure<R ()> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
    MethodClosure_Arg0_Bind4(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg0_Bind4> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg0_Bind4<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg0_Bind4<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg0_Bind4 : public Closure<R ()> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
    FunctionClosure_Arg0_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg0_Bind4> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
           PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg0_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
           PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
                    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg0_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
           PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg0_Bind5 : public Closure<R ()> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    MethodClosure_Arg0_Bind5(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg0_Bind5> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg0_Bind5<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
                    PreArg5 pa5) {
    return new MethodClosure_Arg0_Bind5<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4, typename PreArg5>
class FunctionClosure_Arg0_Bind5 : public Closure<R ()> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    FunctionClosure_Arg0_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg0_Bind5> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
           PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg0_Bind5<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2,
                   pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
                    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg0_Bind5<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1, pa2,
                   pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
     typename PreArg6>
class MethodClosure_Arg0_Bind6 : public Closure<R ()> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    MethodClosure_Arg0_Bind6(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg0_Bind6> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R ()>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
           PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg0_Bind6<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R ()>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
                    PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg0_Bind6<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg0_Bind6 : public Closure<R ()> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    FunctionClosure_Arg0_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run() {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg0_Bind6> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
         typename PreArg6>
Closure<R ()>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
           PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new FunctionClosure_Arg0_Bind6<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
           PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
         typename PreArg6>
Closure<R ()>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
                    PreArg6 pa6) {
    return new FunctionClosure_Arg0_Bind6<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
           PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1 >
class MethodClosure_Arg1_Bind0 : public Closure<R (Arg1)> {
    typedef R (MethodClass::*MethodType)(Arg1);
public:
    MethodClosure_Arg1_Bind0(Class *object, MethodType method):
        m_object(object), m_method(method) {}
    virtual R Run(Arg1 arg1) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg1_Bind0> self_deleter(this);
        return (m_object->*m_method)(arg1);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
};

template <typename R, typename Class, typename MethodClass, typename Arg1>
Closure<R (Arg1)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1)) {
    return new MethodClosure_Arg1_Bind0<false, R, Class, MethodClass, Arg1>(
               object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1>
Closure<R (Arg1)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1)) {
    return new MethodClosure_Arg1_Bind0<true, R, Class, MethodClass, Arg1>(
               object, method);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1>
class FunctionClosure_Arg1_Bind0 : public Closure<R (Arg1)> {
    typedef R (*FunctionType)(Arg1);
public:
    FunctionClosure_Arg1_Bind0(FunctionType function):
        m_function(function) {}
    virtual R Run(Arg1 arg1) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg1_Bind0> self_deleter(this);
        return m_function(arg1);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
};

template <typename R, typename Arg1>
Closure<R (Arg1)>*
NewClosure(R (*function)(Arg1)) {
    return new FunctionClosure_Arg1_Bind0<false, R, Arg1>(function);
}

template <typename R, typename Arg1>
Closure<R (Arg1)>*
NewPermanentClosure(R (*function)(Arg1)) {
    return new FunctionClosure_Arg1_Bind0<true, R, Arg1>(function);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2 , typename PreArg1>
class MethodClosure_Arg1_Bind1 : public Closure<R (Arg2)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2);
public:
    MethodClosure_Arg1_Bind1(Class *object, MethodType method, PreArg1 pa1):
        m_object(object), m_method(method), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg1_Bind1> self_deleter(this);
        return (m_object->*m_method)(m_pa1, arg2);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename PreArg1>
Closure<R (Arg2)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2), PreArg1 pa1) {
    return new MethodClosure_Arg1_Bind1<false, R, Class, MethodClass, Arg1,
           Arg2, PreArg1>(
               object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename PreArg1>
Closure<R (Arg2)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2),
                    PreArg1 pa1) {
    return new MethodClosure_Arg1_Bind1<true, R, Class, MethodClass, Arg1,
           Arg2, PreArg1>(
               object, method, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename PreArg1>
class FunctionClosure_Arg1_Bind1 : public Closure<R (Arg2)> {
    typedef R (*FunctionType)(Arg1, Arg2);
public:
    FunctionClosure_Arg1_Bind1(FunctionType function, PreArg1 pa1):
        m_function(function), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg1_Bind1> self_deleter(this);
        return m_function(m_pa1, arg2);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
};

template <typename R, typename Arg1, typename Arg2, typename PreArg1>
Closure<R (Arg2)>*
NewClosure(R (*function)(Arg1, Arg2), PreArg1 pa1) {
    return new FunctionClosure_Arg1_Bind1<false, R, Arg1, Arg2,
           PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename PreArg1>
Closure<R (Arg2)>*
NewPermanentClosure(R (*function)(Arg1, Arg2), PreArg1 pa1) {
    return new FunctionClosure_Arg1_Bind1<true, R, Arg1, Arg2,
           PreArg1>(function, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
     typename PreArg1, typename PreArg2>
class MethodClosure_Arg1_Bind2 : public Closure<R (Arg3)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3);
public:
    MethodClosure_Arg1_Bind2(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg1_Bind2> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, arg3);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename PreArg1, typename PreArg2>
Closure<R (Arg3)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
           PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg1_Bind2<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename PreArg1, typename PreArg2>
Closure<R (Arg3)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
                    PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg1_Bind2<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1,
     typename PreArg2>
class FunctionClosure_Arg1_Bind2 : public Closure<R (Arg3)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3);
public:
    FunctionClosure_Arg1_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
        m_function(function), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg1_Bind2> self_deleter(this);
        return m_function(m_pa1, m_pa2, arg3);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg1_Bind2<false, R, Arg1, Arg2, Arg3, PreArg1,
           PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg1_Bind2<true, R, Arg1, Arg2, Arg3, PreArg1,
           PreArg2>(function, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4 , typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg1_Bind3 : public Closure<R (Arg4)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
    MethodClosure_Arg1_Bind3(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2),
        m_pa3(pa3) {}
    virtual R Run(Arg4 arg4) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg1_Bind3> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, arg4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
         typename PreArg2, typename PreArg3>
Closure<R (Arg4)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg1_Bind3<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
         typename PreArg2, typename PreArg3>
Closure<R (Arg4)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg1_Bind3<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg1_Bind3 : public Closure<R (Arg4)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
    FunctionClosure_Arg1_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3) {}
    virtual R Run(Arg4 arg4) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg1_Bind3> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, arg4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2,
           PreArg3 pa3) {
    return new FunctionClosure_Arg1_Bind3<false, R, Arg1, Arg2, Arg3, Arg4,
           PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
                    PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg1_Bind3<true, R, Arg1, Arg2, Arg3, Arg4,
           PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4>
class MethodClosure_Arg1_Bind4 : public Closure<R (Arg5)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    MethodClosure_Arg1_Bind4(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4) {}
    virtual R Run(Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg1_Bind4> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg1_Bind4<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg1_Bind4<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4>
class FunctionClosure_Arg1_Bind4 : public Closure<R (Arg5)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    FunctionClosure_Arg1_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4) {}
    virtual R Run(Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg1_Bind4> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4>
Closure<R (Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
           PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg1_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3,
                   pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4>
Closure<R (Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
                    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg1_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2, pa3,
                   pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg1_Bind5 : public Closure<R (Arg6)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    MethodClosure_Arg1_Bind5(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5) {}
    virtual R Run(Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg1_Bind5> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R (Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
           PreArg5 pa5) {
    return new MethodClosure_Arg1_Bind5<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R (Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
                    PreArg5 pa5) {
    return new MethodClosure_Arg1_Bind5<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg1_Bind5 : public Closure<R (Arg6)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    FunctionClosure_Arg1_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5) {}
    virtual R Run(Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg1_Bind5> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
           PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg1_Bind5<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1,
                   pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg1_Bind5<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5>(function, pa1,
                   pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
     typename PreArg5, typename PreArg6>
class MethodClosure_Arg1_Bind6 : public Closure<R (Arg7)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7);
public:
    MethodClosure_Arg1_Bind6(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg1_Bind6> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6,
                                     arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
           PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg1_Bind6<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg1_Bind6<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
     typename PreArg6>
class FunctionClosure_Arg1_Bind6 : public Closure<R (Arg7)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
    FunctionClosure_Arg1_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg1_Bind6> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6, arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R (Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
           PreArg6 pa6) {
    return new FunctionClosure_Arg1_Bind6<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
           PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R (Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
                    PreArg6 pa6) {
    return new FunctionClosure_Arg1_Bind6<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
           PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2 >
class MethodClosure_Arg2_Bind0 : public Closure<R (Arg1, Arg2)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2);
public:
    MethodClosure_Arg2_Bind0(Class *object, MethodType method):
        m_object(object), m_method(method) {}
    virtual R Run(Arg1 arg1, Arg2 arg2) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg2_Bind0> self_deleter(this);
        return (m_object->*m_method)(arg1, arg2);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2>
Closure<R (Arg1, Arg2)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2)) {
    return new MethodClosure_Arg2_Bind0<false, R, Class, MethodClass, Arg1,
           Arg2>(
               object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2>
Closure<R (Arg1, Arg2)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2)) {
    return new MethodClosure_Arg2_Bind0<true, R, Class, MethodClass, Arg1,
           Arg2>(
               object, method);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2>
class FunctionClosure_Arg2_Bind0 : public Closure<R (Arg1, Arg2)> {
    typedef R (*FunctionType)(Arg1, Arg2);
public:
    FunctionClosure_Arg2_Bind0(FunctionType function):
        m_function(function) {}
    virtual R Run(Arg1 arg1, Arg2 arg2) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg2_Bind0> self_deleter(this);
        return m_function(arg1, arg2);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
};

template <typename R, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>*
NewClosure(R (*function)(Arg1, Arg2)) {
    return new FunctionClosure_Arg2_Bind0<false, R, Arg1, Arg2>(function);
}

template <typename R, typename Arg1, typename Arg2>
Closure<R (Arg1, Arg2)>*
NewPermanentClosure(R (*function)(Arg1, Arg2)) {
    return new FunctionClosure_Arg2_Bind0<true, R, Arg1, Arg2>(function);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3 ,
     typename PreArg1>
class MethodClosure_Arg2_Bind1 : public Closure<R (Arg2, Arg3)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3);
public:
    MethodClosure_Arg2_Bind1(Class *object, MethodType method, PreArg1 pa1):
        m_object(object), m_method(method), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg2_Bind1> self_deleter(this);
        return (m_object->*m_method)(m_pa1, arg2, arg3);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename PreArg1>
Closure<R (Arg2, Arg3)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
           PreArg1 pa1) {
    return new MethodClosure_Arg2_Bind1<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, PreArg1>(
               object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename PreArg1>
Closure<R (Arg2, Arg3)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3),
                    PreArg1 pa1) {
    return new MethodClosure_Arg2_Bind1<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, PreArg1>(
               object, method, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename PreArg1>
class FunctionClosure_Arg2_Bind1 : public Closure<R (Arg2, Arg3)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3);
public:
    FunctionClosure_Arg2_Bind1(FunctionType function, PreArg1 pa1):
        m_function(function), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg2_Bind1> self_deleter(this);
        return m_function(m_pa1, arg2, arg3);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename PreArg1>
Closure<R (Arg2, Arg3)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1) {
    return new FunctionClosure_Arg2_Bind1<false, R, Arg1, Arg2, Arg3,
           PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename PreArg1>
Closure<R (Arg2, Arg3)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3), PreArg1 pa1) {
    return new FunctionClosure_Arg2_Bind1<true, R, Arg1, Arg2, Arg3,
           PreArg1>(function, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg2_Bind2 : public Closure<R (Arg3, Arg4)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
    MethodClosure_Arg2_Bind2(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg2_Bind2> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, arg3, arg4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
         typename PreArg2>
Closure<R (Arg3, Arg4)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
           PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg2_Bind2<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename PreArg1,
         typename PreArg2>
Closure<R (Arg3, Arg4)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg2_Bind2<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename PreArg1, typename PreArg2>
class FunctionClosure_Arg2_Bind2 : public Closure<R (Arg3, Arg4)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
    FunctionClosure_Arg2_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
        m_function(function), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg2_Bind2> self_deleter(this);
        return m_function(m_pa1, m_pa2, arg3, arg4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg2_Bind2<false, R, Arg1, Arg2, Arg3, Arg4,
           PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1,
                    PreArg2 pa2) {
    return new FunctionClosure_Arg2_Bind2<true, R, Arg1, Arg2, Arg3, Arg4,
           PreArg1, PreArg2>(function, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2,
     typename PreArg3>
class MethodClosure_Arg2_Bind3 : public Closure<R (Arg4, Arg5)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    MethodClosure_Arg2_Bind3(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2),
        m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg2_Bind3> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, arg4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg2_Bind3<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg2_Bind3<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg2_Bind3 : public Closure<R (Arg4, Arg5)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    FunctionClosure_Arg2_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg2_Bind3> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, arg4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
         typename PreArg3>
Closure<R (Arg4, Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
           PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg2_Bind3<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1, typename PreArg2,
         typename PreArg3>
Closure<R (Arg4, Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
                    PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg2_Bind3<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg2_Bind4 : public Closure<R (Arg5, Arg6)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    MethodClosure_Arg2_Bind4(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg2_Bind4> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg2_Bind4<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg2_Bind4<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4>
class FunctionClosure_Arg2_Bind4 : public Closure<R (Arg5, Arg6)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    FunctionClosure_Arg2_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg2_Bind4> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
           PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg2_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2,
                   pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg2_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1, pa2,
                   pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
     typename PreArg5>
class MethodClosure_Arg2_Bind5 : public Closure<R (Arg6, Arg7)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7);
public:
    MethodClosure_Arg2_Bind5(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg2_Bind5> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6,
                                     arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
           PreArg5 pa5) {
    return new MethodClosure_Arg2_Bind5<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg2_Bind5<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg2_Bind5 : public Closure<R (Arg6, Arg7)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
    FunctionClosure_Arg2_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg2_Bind5> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6, arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R (Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg2_Bind5<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R (Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg2_Bind5<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg2_Bind6 : public Closure<R (Arg7, Arg8)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8);
public:
    MethodClosure_Arg2_Bind6(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg2_Bind6> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6,
                                     arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
           PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg2_Bind6<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg2_Bind6<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
     typename PreArg5, typename PreArg6>
class FunctionClosure_Arg2_Bind6 : public Closure<R (Arg7, Arg8)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
    FunctionClosure_Arg2_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg2_Bind6> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6, arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
           PreArg6 pa6) {
    return new FunctionClosure_Arg2_Bind6<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
           PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
                    PreArg6 pa6) {
    return new FunctionClosure_Arg2_Bind6<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4, PreArg5,
           PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3 >
class MethodClosure_Arg3_Bind0 : public Closure<R (Arg1, Arg2, Arg3)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3);
public:
    MethodClosure_Arg3_Bind0(Class *object, MethodType method):
        m_object(object), m_method(method) {}
    virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg3_Bind0> self_deleter(this);
        return (m_object->*m_method)(arg1, arg2, arg3);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3)) {
    return new MethodClosure_Arg3_Bind0<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3>(
               object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3)) {
    return new MethodClosure_Arg3_Bind0<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3>(
               object, method);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3>
class FunctionClosure_Arg3_Bind0 : public Closure<R (Arg1, Arg2, Arg3)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3);
public:
    FunctionClosure_Arg3_Bind0(FunctionType function):
        m_function(function) {}
    virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg3_Bind0> self_deleter(this);
        return m_function(arg1, arg2, arg3);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3)) {
    return new FunctionClosure_Arg3_Bind0<false, R, Arg1, Arg2, Arg3>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3>
Closure<R (Arg1, Arg2, Arg3)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3)) {
    return new FunctionClosure_Arg3_Bind0<true, R, Arg1, Arg2, Arg3>(function);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4 , typename PreArg1>
class MethodClosure_Arg3_Bind1 : public Closure<R (Arg2, Arg3, Arg4)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
    MethodClosure_Arg3_Bind1(Class *object, MethodType method, PreArg1 pa1):
        m_object(object), m_method(method), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg3_Bind1> self_deleter(this);
        return (m_object->*m_method)(m_pa1, arg2, arg3, arg4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4),
           PreArg1 pa1) {
    return new MethodClosure_Arg3_Bind1<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, PreArg1>(
               object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4), PreArg1 pa1) {
    return new MethodClosure_Arg3_Bind1<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, PreArg1>(
               object, method, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename PreArg1>
class FunctionClosure_Arg3_Bind1 : public Closure<R (Arg2, Arg3, Arg4)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
    FunctionClosure_Arg3_Bind1(FunctionType function, PreArg1 pa1):
        m_function(function), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg3_Bind1> self_deleter(this);
        return m_function(m_pa1, arg2, arg3, arg4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1) {
    return new FunctionClosure_Arg3_Bind1<false, R, Arg1, Arg2, Arg3, Arg4,
           PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4), PreArg1 pa1) {
    return new FunctionClosure_Arg3_Bind1<true, R, Arg1, Arg2, Arg3, Arg4,
           PreArg1>(function, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg3_Bind2 : public Closure<R (Arg3, Arg4, Arg5)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    MethodClosure_Arg3_Bind2(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg3_Bind2> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, arg3, arg4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg3_Bind2<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg3_Bind2<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename PreArg1, typename PreArg2>
class FunctionClosure_Arg3_Bind2 : public Closure<R (Arg3, Arg4, Arg5)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    FunctionClosure_Arg3_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
        m_function(function), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg3_Bind2> self_deleter(this);
        return m_function(m_pa1, m_pa2, arg3, arg4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
           PreArg2 pa2) {
    return new FunctionClosure_Arg3_Bind2<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1,
                    PreArg2 pa2) {
    return new FunctionClosure_Arg3_Bind2<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1, PreArg2>(function, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
     typename PreArg2, typename PreArg3>
class MethodClosure_Arg3_Bind3 : public Closure<R (Arg4, Arg5, Arg6)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    MethodClosure_Arg3_Bind3(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2),
        m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg3_Bind3> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, arg4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg3_Bind3<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg3_Bind3<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename PreArg1, typename PreArg2,
     typename PreArg3>
class FunctionClosure_Arg3_Bind3 : public Closure<R (Arg4, Arg5, Arg6)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    FunctionClosure_Arg3_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg3_Bind3> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, arg4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
           PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg3_Bind3<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg3_Bind3<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg3_Bind4 : public Closure<R (Arg5, Arg6, Arg7)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7);
public:
    MethodClosure_Arg3_Bind4(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg3_Bind4> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6,
                                     arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4>
Closure<R (Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg3_Bind4<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
           PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4>
Closure<R (Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4) {
    return new MethodClosure_Arg3_Bind4<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3,
           PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg3_Bind4 : public Closure<R (Arg5, Arg6, Arg7)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
    FunctionClosure_Arg3_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg3_Bind4> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6, arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg3_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1,
                   pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg3_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3, PreArg4>(function, pa1,
                   pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4, typename PreArg5>
class MethodClosure_Arg3_Bind5 : public Closure<R (Arg6, Arg7, Arg8)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8);
public:
    MethodClosure_Arg3_Bind5(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg3_Bind5> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6,
                                     arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
           PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg3_Bind5<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg3_Bind5<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
     typename PreArg5>
class FunctionClosure_Arg3_Bind5 : public Closure<R (Arg6, Arg7, Arg8)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
    FunctionClosure_Arg3_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg3_Bind5> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6, arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R (Arg6, Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg3_Bind5<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R (Arg6, Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg3_Bind5<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg3_Bind6 : public Closure<R (Arg7, Arg8, Arg9)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9);
public:
    MethodClosure_Arg3_Bind6(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg3_Bind6> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6,
                                     arg7, arg8, arg9);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
         typename PreArg6>
Closure<R (Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
           PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg3_Bind6<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
           PreArg3, PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
         typename PreArg6>
Closure<R (Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg3_Bind6<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
           PreArg3, PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg3_Bind6 : public Closure<R (Arg7, Arg8, Arg9)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9);
public:
    FunctionClosure_Arg3_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg3_Bind6> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6, arg7, arg8,
                          arg9);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
           PreArg6 pa6) {
    return new FunctionClosure_Arg3_Bind6<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
                    PreArg5 pa5, PreArg6 pa6) {
    return new FunctionClosure_Arg3_Bind6<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4 >
class MethodClosure_Arg4_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4);
public:
    MethodClosure_Arg4_Bind0(Class *object, MethodType method):
        m_object(object), m_method(method) {}
    virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg4_Bind0> self_deleter(this);
        return (m_object->*m_method)(arg1, arg2, arg3, arg4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4)) {
    return new MethodClosure_Arg4_Bind0<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4>(
               object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4)) {
    return new MethodClosure_Arg4_Bind0<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4>(
               object, method);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4>
class FunctionClosure_Arg4_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4);
public:
    FunctionClosure_Arg4_Bind0(FunctionType function):
        m_function(function) {}
    virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg4_Bind0> self_deleter(this);
        return m_function(arg1, arg2, arg3, arg4);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4)) {
    return new FunctionClosure_Arg4_Bind0<false, R, Arg1, Arg2, Arg3,
           Arg4>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4>
Closure<R (Arg1, Arg2, Arg3, Arg4)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4)) {
    return new FunctionClosure_Arg4_Bind0<true, R, Arg1, Arg2, Arg3,
           Arg4>(function);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5 , typename PreArg1>
class MethodClosure_Arg4_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    MethodClosure_Arg4_Bind1(Class *object, MethodType method, PreArg1 pa1):
        m_object(object), m_method(method), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg4_Bind1> self_deleter(this);
        return (m_object->*m_method)(m_pa1, arg2, arg3, arg4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5), PreArg1 pa1) {
    return new MethodClosure_Arg4_Bind1<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1>(
               object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5,
         typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5), PreArg1 pa1) {
    return new MethodClosure_Arg4_Bind1<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, PreArg1>(
               object, method, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename PreArg1>
class FunctionClosure_Arg4_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    FunctionClosure_Arg4_Bind1(FunctionType function, PreArg1 pa1):
        m_function(function), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg4_Bind1> self_deleter(this);
        return m_function(m_pa1, arg2, arg3, arg4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1) {
    return new FunctionClosure_Arg4_Bind1<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5), PreArg1 pa1) {
    return new FunctionClosure_Arg4_Bind1<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, PreArg1>(function, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6 , typename PreArg1,
     typename PreArg2>
class MethodClosure_Arg4_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    MethodClosure_Arg4_Bind2(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg4_Bind2> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, arg3, arg4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg4_Bind2<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg4_Bind2<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename PreArg1, typename PreArg2>
class FunctionClosure_Arg4_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    FunctionClosure_Arg4_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
        m_function(function), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg4_Bind2> self_deleter(this);
        return m_function(m_pa1, m_pa2, arg3, arg4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1,
           PreArg2 pa2) {
    return new FunctionClosure_Arg4_Bind2<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1,
         typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
                    PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg4_Bind2<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1, PreArg2>(function, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
     typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg4_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7);
public:
    MethodClosure_Arg4_Bind3(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2),
        m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg4_Bind3> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, arg4, arg5, arg6,
                                     arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg4_Bind3<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg4_Bind3<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
     typename PreArg2, typename PreArg3>
class FunctionClosure_Arg4_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
    FunctionClosure_Arg4_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg4_Bind3> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, arg4, arg5, arg6, arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg4_Bind3<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
                    PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg4_Bind3<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2, PreArg3>(function, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4>
class MethodClosure_Arg4_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8);
public:
    MethodClosure_Arg4_Bind4(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg4_Bind4> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6,
                                     arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
           PreArg4 pa4) {
    return new MethodClosure_Arg4_Bind4<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3,
           PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4) {
    return new MethodClosure_Arg4_Bind4<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3,
           PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
class FunctionClosure_Arg4_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
    FunctionClosure_Arg4_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg4_Bind4> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6, arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg4_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(function,
                   pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg4_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3, PreArg4>(function,
                   pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg4_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9);
public:
    MethodClosure_Arg4_Bind5(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg4_Bind5> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6,
                                     arg7, arg8, arg9);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
           PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg4_Bind5<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
           PreArg3, PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg4_Bind5<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
           PreArg3, PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4, typename PreArg5>
class FunctionClosure_Arg4_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9);
public:
    FunctionClosure_Arg4_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg4_Bind5> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6, arg7, arg8,
                          arg9);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg4_Bind5<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
                    PreArg5 pa5) {
    return new FunctionClosure_Arg4_Bind5<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3, PreArg4,
           PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
     typename PreArg6>
class MethodClosure_Arg4_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9, Arg10);
public:
    MethodClosure_Arg4_Bind6(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg4_Bind6> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6,
                                     arg7, arg8, arg9, arg10);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
           PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg4_Bind6<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
           PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
                    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg4_Bind6<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
           PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
class FunctionClosure_Arg4_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9, Arg10);
public:
    FunctionClosure_Arg4_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg4_Bind6> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6, arg7, arg8,
                          arg9, arg10);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
                         Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5,
           PreArg6 pa6) {
    return new FunctionClosure_Arg4_Bind6<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
                    PreArg5 pa5, PreArg6 pa6) {
    return new FunctionClosure_Arg4_Bind6<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5 >
class MethodClosure_Arg5_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
                Arg5)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    MethodClosure_Arg5_Bind0(Class *object, MethodType method):
        m_object(object), m_method(method) {}
    virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg5_Bind0> self_deleter(this);
        return (m_object->*m_method)(arg1, arg2, arg3, arg4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5)) {
    return new MethodClosure_Arg5_Bind0<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5>(
               object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5)) {
    return new MethodClosure_Arg5_Bind0<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5>(
               object, method);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5>
class FunctionClosure_Arg5_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
                Arg5)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5);
public:
    FunctionClosure_Arg5_Bind0(FunctionType function):
        m_function(function) {}
    virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg5_Bind0> self_deleter(this);
        return m_function(arg1, arg2, arg3, arg4, arg5);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
    return new FunctionClosure_Arg5_Bind0<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5)) {
    return new FunctionClosure_Arg5_Bind0<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5>(function);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6 , typename PreArg1>
class MethodClosure_Arg5_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
                Arg6)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    MethodClosure_Arg5_Bind1(Class *object, MethodType method, PreArg1 pa1):
        m_object(object), m_method(method), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg5_Bind1> self_deleter(this);
        return (m_object->*m_method)(m_pa1, arg2, arg3, arg4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6), PreArg1 pa1) {
    return new MethodClosure_Arg5_Bind1<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1>(
               object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6), PreArg1 pa1) {
    return new MethodClosure_Arg5_Bind1<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, PreArg1>(
               object, method, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename PreArg1>
class FunctionClosure_Arg5_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
                Arg6)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    FunctionClosure_Arg5_Bind1(FunctionType function, PreArg1 pa1):
        m_function(function), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg5_Bind1> self_deleter(this);
        return m_function(m_pa1, arg2, arg3, arg4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6), PreArg1 pa1) {
    return new FunctionClosure_Arg5_Bind1<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6),
                    PreArg1 pa1) {
    return new FunctionClosure_Arg5_Bind1<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, PreArg1>(function, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
     typename PreArg1, typename PreArg2>
class MethodClosure_Arg5_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
                Arg7)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7);
public:
    MethodClosure_Arg5_Bind2(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg5_Bind2> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, arg3, arg4, arg5, arg6,
                                     arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg5_Bind2<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg5_Bind2<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename PreArg1,
     typename PreArg2>
class FunctionClosure_Arg5_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
                Arg7)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
    FunctionClosure_Arg5_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
        m_function(function), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg5_Bind2> self_deleter(this);
        return m_function(m_pa1, m_pa2, arg3, arg4, arg5, arg6, arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
           PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg5_Bind2<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
                    PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg5_Bind2<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1, PreArg2>(function, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8 , typename PreArg1, typename PreArg2, typename PreArg3>
class MethodClosure_Arg5_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
                Arg8)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8);
public:
    MethodClosure_Arg5_Bind3(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2),
        m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg5_Bind3> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, arg4, arg5, arg6,
                                     arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
         typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg5_Bind3<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2,
         typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg5_Bind3<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(
               object, method, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg5_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
                Arg8)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
    FunctionClosure_Arg5_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg5_Bind3> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, arg4, arg5, arg6, arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg5_Bind3<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(function, pa1, pa2,
                   pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg5_Bind3<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2, PreArg3>(function, pa1, pa2,
                   pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4>
class MethodClosure_Arg5_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
                Arg9)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9);
public:
    MethodClosure_Arg5_Bind4(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg5_Bind4> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6,
                                     arg7, arg8, arg9);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
           PreArg4 pa4) {
    return new MethodClosure_Arg5_Bind4<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
           PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4) {
    return new MethodClosure_Arg5_Bind4<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
           PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4>
class FunctionClosure_Arg5_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
                Arg9)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9);
public:
    FunctionClosure_Arg5_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg5_Bind4> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6, arg7, arg8,
                          arg9);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg5_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
           PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg5_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3,
           PreArg4>(function, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class MethodClosure_Arg5_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
                Arg10)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9, Arg10);
public:
    MethodClosure_Arg5_Bind5(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg5_Bind5> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6,
                                     arg7, arg8, arg9, arg10);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
           PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg5_Bind5<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
           PreArg2, PreArg3, PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
                    PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg5_Bind5<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
           PreArg2, PreArg3, PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg5_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
                Arg10)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9, Arg10);
public:
    FunctionClosure_Arg5_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg5_Bind5> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6, arg7, arg8,
                          arg9, arg10);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
                         Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg5_Bind5<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
                    PreArg5 pa5) {
    return new FunctionClosure_Arg5_Bind5<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9, typename Arg10, typename Arg11 ,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
     typename PreArg5, typename PreArg6>
class MethodClosure_Arg5_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
                Arg11)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9, Arg10, Arg11);
public:
    MethodClosure_Arg5_Bind6(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg5_Bind6> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6,
                                     arg7, arg8, arg9, arg10, arg11);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
           PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg5_Bind6<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1,
           PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1,
                    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg5_Bind6<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1,
           PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
     typename PreArg6>
class FunctionClosure_Arg5_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
                Arg11)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9, Arg10, Arg11);
public:
    FunctionClosure_Arg5_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg5_Bind6> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6, arg7, arg8,
                          arg9, arg10, arg11);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
         typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
                         Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
           PreArg5 pa5, PreArg6 pa6) {
    return new FunctionClosure_Arg5_Bind6<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5,
         typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new FunctionClosure_Arg5_Bind6<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6 >
class MethodClosure_Arg6_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
                Arg5, Arg6)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    MethodClosure_Arg6_Bind0(Class *object, MethodType method):
        m_object(object), m_method(method) {}
    virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,
                  Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg6_Bind0> self_deleter(this);
        return (m_object->*m_method)(arg1, arg2, arg3, arg4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6)) {
    return new MethodClosure_Arg6_Bind0<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6>(
               object, method);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6)) {
    return new MethodClosure_Arg6_Bind0<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6>(
               object, method);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6>
class FunctionClosure_Arg6_Bind0 : public Closure<R (Arg1, Arg2, Arg3, Arg4,
                Arg5, Arg6)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);
public:
    FunctionClosure_Arg6_Bind0(FunctionType function):
        m_function(function) {}
    virtual R Run(Arg1 arg1, Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5,
                  Arg6 arg6) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg6_Bind0> self_deleter(this);
        return m_function(arg1, arg2, arg3, arg4, arg5, arg6);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
    return new FunctionClosure_Arg6_Bind0<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6>(function);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6>
Closure<R (Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6)) {
    return new FunctionClosure_Arg6_Bind0<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6>(function);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7 ,
     typename PreArg1>
class MethodClosure_Arg6_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
                Arg6, Arg7)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7);
public:
    MethodClosure_Arg6_Bind1(Class *object, MethodType method, PreArg1 pa1):
        m_object(object), m_method(method), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,
                  Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg6_Bind1> self_deleter(this);
        return (m_object->*m_method)(m_pa1, arg2, arg3, arg4, arg5, arg6, arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7), PreArg1 pa1) {
    return new MethodClosure_Arg6_Bind1<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
               object, method, pa1);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7), PreArg1 pa1) {
    return new MethodClosure_Arg6_Bind1<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, PreArg1>(
               object, method, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename PreArg1>
class FunctionClosure_Arg6_Bind1 : public Closure<R (Arg2, Arg3, Arg4, Arg5,
                Arg6, Arg7)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);
public:
    FunctionClosure_Arg6_Bind1(FunctionType function, PreArg1 pa1):
        m_function(function), m_pa1(pa1) {}
    virtual R Run(Arg2 arg2, Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6,
                  Arg7 arg7) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg6_Bind1> self_deleter(this);
        return m_function(m_pa1, arg2, arg3, arg4, arg5, arg6, arg7);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
           PreArg1 pa1) {
    return new FunctionClosure_Arg6_Bind1<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1>(function, pa1);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7,
         typename PreArg1>
Closure<R (Arg2, Arg3, Arg4, Arg5, Arg6, Arg7)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7),
                    PreArg1 pa1) {
    return new FunctionClosure_Arg6_Bind1<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, PreArg1>(function, pa1);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8 , typename PreArg1, typename PreArg2>
class MethodClosure_Arg6_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
                Arg7, Arg8)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8);
public:
    MethodClosure_Arg6_Bind2(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,
                  Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg6_Bind2> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, arg3, arg4, arg5, arg6,
                                     arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg6_Bind2<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8), PreArg1 pa1, PreArg2 pa2) {
    return new MethodClosure_Arg6_Bind2<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(
               object, method, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename PreArg1, typename PreArg2>
class FunctionClosure_Arg6_Bind2 : public Closure<R (Arg3, Arg4, Arg5, Arg6,
                Arg7, Arg8)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);
public:
    FunctionClosure_Arg6_Bind2(FunctionType function, PreArg1 pa1, PreArg2 pa2):
        m_function(function), m_pa1(pa1), m_pa2(pa2) {}
    virtual R Run(Arg3 arg3, Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7,
                  Arg8 arg8) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg6_Bind2> self_deleter(this);
        return m_function(m_pa1, m_pa2, arg3, arg4, arg5, arg6, arg7, arg8);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8),
           PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg6_Bind2<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(function, pa1, pa2);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename PreArg1, typename PreArg2>
Closure<R (Arg3, Arg4, Arg5, Arg6, Arg7, Arg8)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8), PreArg1 pa1, PreArg2 pa2) {
    return new FunctionClosure_Arg6_Bind2<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, PreArg1, PreArg2>(function, pa1, pa2);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9 , typename PreArg1, typename PreArg2,
     typename PreArg3>
class MethodClosure_Arg6_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
                Arg8, Arg9)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9);
public:
    MethodClosure_Arg6_Bind3(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2),
        m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,
                  Arg9 arg9) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg6_Bind3> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, arg4, arg5, arg6,
                                     arg7, arg8, arg9);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
         typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new MethodClosure_Arg6_Bind3<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
           PreArg3>(
               object, method, pa1, pa2, pa3);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename PreArg1,
         typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9), PreArg1 pa1, PreArg2 pa2,
                    PreArg3 pa3) {
    return new MethodClosure_Arg6_Bind3<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2,
           PreArg3>(
               object, method, pa1, pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
class FunctionClosure_Arg6_Bind3 : public Closure<R (Arg4, Arg5, Arg6, Arg7,
                Arg8, Arg9)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9);
public:
    FunctionClosure_Arg6_Bind3(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3) {}
    virtual R Run(Arg4 arg4, Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8,
                  Arg9 arg9) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg6_Bind3> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, arg4, arg5, arg6, arg7, arg8,
                          arg9);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9),
           PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg6_Bind3<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(function, pa1,
                   pa2, pa3);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename PreArg1, typename PreArg2, typename PreArg3>
Closure<R (Arg4, Arg5, Arg6, Arg7, Arg8, Arg9)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3) {
    return new FunctionClosure_Arg6_Bind3<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, PreArg1, PreArg2, PreArg3>(function, pa1,
                   pa2, pa3);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9, typename Arg10 , typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4>
class MethodClosure_Arg6_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
                Arg9, Arg10)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9, Arg10);
public:
    MethodClosure_Arg6_Bind4(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,
                  Arg10 arg10) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg6_Bind4> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6,
                                     arg7, arg8, arg9, arg10);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
           PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg6_Bind4<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
           PreArg2, PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2,
                    PreArg3 pa3, PreArg4 pa4) {
    return new MethodClosure_Arg6_Bind4<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1,
           PreArg2, PreArg3, PreArg4>(
               object, method, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
     typename PreArg3, typename PreArg4>
class FunctionClosure_Arg6_Bind4 : public Closure<R (Arg5, Arg6, Arg7, Arg8,
                Arg9, Arg10)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9, Arg10);
public:
    FunctionClosure_Arg6_Bind4(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4) {}
    virtual R Run(Arg5 arg5, Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9,
                  Arg10 arg10) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg6_Bind4> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, arg5, arg6, arg7, arg8,
                          arg9, arg10);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
                         Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg6_Bind4<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
           PreArg4>(function, pa1, pa2, pa3, pa4);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4>
Closure<R (Arg5, Arg6, Arg7, Arg8, Arg9, Arg10)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9, Arg10), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4) {
    return new FunctionClosure_Arg6_Bind4<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, PreArg1, PreArg2, PreArg3,
           PreArg4>(function, pa1, pa2, pa3, pa4);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9, typename Arg10, typename Arg11 ,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
     typename PreArg5>
class MethodClosure_Arg6_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
                Arg10, Arg11)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9, Arg10, Arg11);
public:
    MethodClosure_Arg6_Bind5(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10,
                  Arg11 arg11) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg6_Bind5> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6,
                                     arg7, arg8, arg9, arg10, arg11);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2,
           PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg6_Bind5<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1,
           PreArg2, PreArg3, PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename Arg11, typename PreArg1, typename PreArg2, typename PreArg3,
         typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11), PreArg1 pa1,
                    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5) {
    return new MethodClosure_Arg6_Bind5<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1,
           PreArg2, PreArg3, PreArg4, PreArg5>(
               object, method, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
     typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
class FunctionClosure_Arg6_Bind5 : public Closure<R (Arg6, Arg7, Arg8, Arg9,
                Arg10, Arg11)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9, Arg10, Arg11);
public:
    FunctionClosure_Arg6_Bind5(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5) {}
    virtual R Run(Arg6 arg6, Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10,
                  Arg11 arg11) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg6_Bind5> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, arg6, arg7, arg8,
                          arg9, arg10, arg11);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
                         Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
           PreArg5 pa5) {
    return new FunctionClosure_Arg6_Bind5<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename Arg11, typename PreArg1,
         typename PreArg2, typename PreArg3, typename PreArg4, typename PreArg5>
Closure<R (Arg6, Arg7, Arg8, Arg9, Arg10, Arg11)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9, Arg10, Arg11), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5) {
    return new FunctionClosure_Arg6_Bind5<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, PreArg1, PreArg2, PreArg3,
           PreArg4, PreArg5>(function, pa1, pa2, pa3, pa4, pa5);
}

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
bool Permanent,
     typename R,
     typename Class,
     typename MethodClass, typename Arg1, typename Arg2, typename Arg3,
     typename Arg4, typename Arg5, typename Arg6, typename Arg7,
     typename Arg8, typename Arg9, typename Arg10, typename Arg11,
     typename Arg12 , typename PreArg1, typename PreArg2, typename PreArg3,
     typename PreArg4, typename PreArg5, typename PreArg6>
class MethodClosure_Arg6_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
                Arg11, Arg12)> {
    typedef R (MethodClass::*MethodType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6,
                                         Arg7, Arg8, Arg9, Arg10, Arg11, Arg12);
public:
    MethodClosure_Arg6_Bind6(Class *object, MethodType method, PreArg1 pa1,
                             PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_object(object), m_method(method), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3),
        m_pa4(pa4), m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11,
                  Arg12 arg12) {
        ConditionalAutoDeleter<!Permanent,
                               MethodClosure_Arg6_Bind6> self_deleter(this);
        return (m_object->*m_method)(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6,
                                     arg7, arg8, arg9, arg10, arg11, arg12);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    Class* m_object;
    MethodType m_method;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename Arg11, typename Arg12, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1,
           PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg6_Bind6<false, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
           PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

template <typename R, typename Class, typename MethodClass, typename Arg1,
         typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6,
         typename Arg7, typename Arg8, typename Arg9, typename Arg10,
         typename Arg11, typename Arg12, typename PreArg1, typename PreArg2,
         typename PreArg3, typename PreArg4, typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewPermanentClosure(Class *object, R (MethodClass::*method)(Arg1, Arg2, Arg3,
                    Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1,
                    PreArg2 pa2, PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new MethodClosure_Arg6_Bind6<true, R, Class, MethodClass, Arg1,
           Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12,
           PreArg1, PreArg2, PreArg3, PreArg4, PreArg5, PreArg6>(
               object, method, pa1, pa2, pa3, pa4, pa5, pa6);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
bool Permanent,
     typename R, typename Arg1, typename Arg2, typename Arg3, typename Arg4,
     typename Arg5, typename Arg6, typename Arg7, typename Arg8,
     typename Arg9, typename Arg10, typename Arg11, typename Arg12,
     typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
     typename PreArg5, typename PreArg6>
class FunctionClosure_Arg6_Bind6 : public Closure<R (Arg7, Arg8, Arg9, Arg10,
                Arg11, Arg12)> {
    typedef R (*FunctionType)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8,
                              Arg9, Arg10, Arg11, Arg12);
public:
    FunctionClosure_Arg6_Bind6(FunctionType function, PreArg1 pa1, PreArg2 pa2,
                               PreArg3 pa3, PreArg4 pa4, PreArg5 pa5, PreArg6 pa6):
        m_function(function), m_pa1(pa1), m_pa2(pa2), m_pa3(pa3), m_pa4(pa4),
        m_pa5(pa5), m_pa6(pa6) {}
    virtual R Run(Arg7 arg7, Arg8 arg8, Arg9 arg9, Arg10 arg10, Arg11 arg11,
                  Arg12 arg12) {
        ConditionalAutoDeleter<!Permanent,
                               FunctionClosure_Arg6_Bind6> self_deleter(this);
        return m_function(m_pa1, m_pa2, m_pa3, m_pa4, m_pa5, m_pa6, arg7, arg8,
                          arg9, arg10, arg11, arg12);
    }
    virtual bool IsPermanent() const {
        return Permanent;
    }
private:
    FunctionType m_function;
    PreArg1 m_pa1;
    PreArg2 m_pa2;
    PreArg3 m_pa3;
    PreArg4 m_pa4;
    PreArg5 m_pa5;
    PreArg6 m_pa6;
};

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename Arg11, typename Arg12,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9,
                         Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3, PreArg4 pa4,
           PreArg5 pa5, PreArg6 pa6) {
    return new FunctionClosure_Arg6_Bind6<false, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1, PreArg2,
           PreArg3, PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5,
                   pa6);
}

template <typename R, typename Arg1, typename Arg2, typename Arg3,
         typename Arg4, typename Arg5, typename Arg6, typename Arg7, typename Arg8,
         typename Arg9, typename Arg10, typename Arg11, typename Arg12,
         typename PreArg1, typename PreArg2, typename PreArg3, typename PreArg4,
         typename PreArg5, typename PreArg6>
Closure<R (Arg7, Arg8, Arg9, Arg10, Arg11, Arg12)>*
NewPermanentClosure(R (*function)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7,
                                  Arg8, Arg9, Arg10, Arg11, Arg12), PreArg1 pa1, PreArg2 pa2, PreArg3 pa3,
                    PreArg4 pa4, PreArg5 pa5, PreArg6 pa6) {
    return new FunctionClosure_Arg6_Bind6<true, R, Arg1, Arg2, Arg3, Arg4,
           Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, PreArg1, PreArg2,
           PreArg3, PreArg4, PreArg5, PreArg6>(function, pa1, pa2, pa3, pa4, pa5,
                   pa6);
}

} // namespace toft

#endif // TOFT_BASE_CLOSURE_H
