// Copyright (c) 2013, The Toft Authors.
// All rights reserved.
//
// Author: CHEN Feng <chen3feng@gmail.com>

/////////////////////////////////////////////////////
// DO NOT EDIT!!!
// This header file is auto generated by the command: pump.py closure.h.pump
// Edit the generator if necessary.
/////////////////////////////////////////////////////

#ifndef TOFT_BASE_CLOSURE_H
#define TOFT_BASE_CLOSURE_H

#include "toft/base/cxx11.h"

// GLOBAL_NOLINT(whitespace/indent)
// GLOBAL_NOLINT(whitespace/line_length)
// GLOBAL_NOLINT(whitespace/parens)

namespace toft {

// Base class for all Closures
class ClosureBase
{
public:
    virtual ~ClosureBase();
    virtual bool IsPermanent() const = 0;
};

// Primary template
template <typename Signature>class Closure : public ClosureBase
{
};

$var total_args = 6
$range i 0..total_args

$for i [[

$range j 1..i

// Specified for $i arguments
template <
    typename R $for j [[, typename A$j]]
>
class Closure<R ($for j, [[A$j]])>
    : public ClosureBase
{
public:
    virtual R Run($for j, [[A$j a$j]]) = 0;
};

]]

// Delete p in dtor automatically if Enabled is true
template <bool Enabled, typename T>
class ConditionalAutoDeleter
{
public:
    explicit ConditionalAutoDeleter(T* p)
        : m_p(p)
    {
    }
    ~ConditionalAutoDeleter()
    {
        if (Enabled)
            delete m_p;
    }
private:
    ConditionalAutoDeleter(const ConditionalAutoDeleter&);
    ConditionalAutoDeleter& operator=(const ConditionalAutoDeleter&);
private:
    T* m_p;
};

$var total_bind_args = total_args

$range nleft_args 0..total_args
$range nbind_args 0..total_args

$for nleft_args [[
$for nbind_args [[

$var nargs = nleft_args + nbind_args
$range j 1..nbind_args
$range k 1..nargs
$range i nbind_args+1..nargs

/////////////////////////////////////////////////////////////////////////////
// Class method closures

template <
    bool Permanent,
    typename R,
    typename Class,
    typename MethodClass$for k [[, typename Arg$k]] $for j [[, typename PreArg$j]]
>
class MethodClosure_Arg$(nleft_args)_Bind$nbind_args : public Closure<R ($for i, [[Arg$i]])> {
    typedef R (MethodClass::*MethodType)($for k, [[Arg$k]]);
public:
    MethodClosure_Arg$(nleft_args)_Bind$nbind_args(Class *object, MethodType method$for j [[, PreArg$j pa$j]]):
        m_object(object), m_method(method)$for j [[, m_pa$j(pa$j)]] {}
    virtual R Run($for i, [[Arg$i arg$i]]) {
        ConditionalAutoDeleter<!Permanent, MethodClosure_Arg$(nleft_args)_Bind$nbind_args> self_deleter(this);
        return (m_object->*m_method)($for j, [[m_pa$j]]$if nleft_args > 0[[$if nbind_args > 0[[, ]]]]$for i, [[arg$i]]);
    }
    virtual bool IsPermanent() const { return Permanent; }
private:
    Class* m_object;
    MethodType m_method;

$for j [[
    PreArg$j m_pa$j;

]]
};

template <typename R, typename Class, typename MethodClass$for k [[, typename Arg$k]]$for j [[, typename PreArg$j]]>
Closure<R ($for i, [[Arg$i]])>*
NewClosure(Class *object, R (MethodClass::*method)($for k, [[Arg$k]])$for j [[, PreArg$j pa$j]]) {
    return new MethodClosure_Arg$(nleft_args)_Bind$nbind_args<false, R, Class, MethodClass$for k [[, Arg$k]]$for j[[, PreArg$j]]>(
        object, method$for j [[, pa$j]]);
}

template <typename R, typename Class, typename MethodClass$for k [[, typename Arg$k]]$for j [[, typename PreArg$j]]>
Closure<R ($for i, [[Arg$i]])>*
NewPermanentClosure(Class *object, R (MethodClass::*method)($for k, [[Arg$k]])$for j [[, PreArg$j pa$j]]) {
    return new MethodClosure_Arg$(nleft_args)_Bind$nbind_args<true, R, Class, MethodClass$for k [[, Arg$k]]$for j[[, PreArg$j]]>(
        object, method$for j [[, pa$j]]);
}

/////////////////////////////////////////////////////////////////////////////
// Normal function closures

template <
    bool Permanent,
    typename R$for k [[, typename Arg$k]]$for j [[, typename PreArg$j]]
>
class FunctionClosure_Arg$(nleft_args)_Bind$nbind_args : public Closure<R ($for i, [[Arg$i]])> {
    typedef R (*FunctionType)($for k, [[Arg$k]]);
public:
    FunctionClosure_Arg$(nleft_args)_Bind$nbind_args(FunctionType function$for j [[, PreArg$j pa$j]]):
        m_function(function)$for j [[, m_pa$j(pa$j)]] {}
    virtual R Run($for i, [[Arg$i arg$i]]) {
        ConditionalAutoDeleter<!Permanent, FunctionClosure_Arg$(nleft_args)_Bind$nbind_args> self_deleter(this);
        return m_function($for j, [[m_pa$j]]$if nleft_args > 0[[$if nbind_args > 0[[, ]]]]$for i, [[arg$i]]);
    }
    virtual bool IsPermanent() const { return Permanent; }
private:
    FunctionType m_function;

$for j [[
    PreArg$j m_pa$j;

]]
};

template <typename R$for k [[, typename Arg$k]]$for j [[, typename PreArg$j]]>
Closure<R ($for i, [[Arg$i]])>*
NewClosure(R (*function)($for k, [[Arg$k]])$for j [[, PreArg$j pa$j]]) {
    return new FunctionClosure_Arg$(nleft_args)_Bind$nbind_args<false, R$for k [[, Arg$k]]$for j [[, PreArg$j]]>(function$for j [[, pa$j]]);
}

template <typename R$for k [[, typename Arg$k]]$for j [[, typename PreArg$j]]>
Closure<R ($for i, [[Arg$i]])>*
NewPermanentClosure(R (*function)($for k, [[Arg$k]])$for j [[, PreArg$j pa$j]]) {
    return new FunctionClosure_Arg$(nleft_args)_Bind$nbind_args<true, R$for k [[, Arg$k]]$for j [[, PreArg$j]]>(function$for j [[, pa$j]]);
}

]]
]]

// FunctorClosure accepts arbitrary functor, e.g. lambda expression.
#ifdef TOFT_CXX11_ENABLED
template<bool Permanent, typename F, typename R>
class FunctorClosure : public Closure<R ()> {
public:
    explicit FunctorClosure(const F& functor)
        : m_functor(functor) { }

    bool IsPermanent() const {
        return Permanent;
    }

    R Run() {
        ConditionalAutoDeleter<!Permanent, FunctorClosure> self_deleter(this);
        return m_functor();
    }

private:
    F m_functor;
};

template <typename F>
auto NewClosure(const F& functor) -> Closure<decltype(functor())()>* {
    return new FunctorClosure<false, F, decltype(functor())>(functor);
}

template <typename F>
auto NewPermanentClosure(const F& functor) -> Closure<decltype(functor())()>* {
    return new FunctorClosure<true, F, decltype(functor())>(functor);
}
#endif

} // namespace toft

#endif // TOFT_BASE_CLOSURE_H
